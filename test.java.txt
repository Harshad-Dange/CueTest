package com.zimplistic.rotimatic.remote.mqtt;

import java.io.UnsupportedEncodingException;
import java.util.UUID;
import java.util.logging.Logger;

import com.amazonaws.auth.AWSSessionCredentials;
import com.amazonaws.auth.CognitoCredentialsProvider;
import com.amazonaws.mobileconnectors.iot.AWSIotMqttClientStatusCallback;
import com.amazonaws.mobileconnectors.iot.AWSIotMqttManager;
import com.amazonaws.mobileconnectors.iot.AWSIotMqttNewMessageCallback;
import com.amazonaws.mobileconnectors.iot.AWSIotMqttQos;
import com.amazonaws.regions.Regions;
import com.zimplistic.rotimatic.commonautomationframework.CustomLogger;
import com.zimplistic.rotimatic.constants.MqttConstants;
import com.zimplistic.rotimatic.remote.models.MqttTopicsHelper;
import com.zimplistic.rotimatic.remote.models.RTRemoteUtils;
// This is test
public class MQTTConnect {

	private static final String TAG = MQTTConnect.class.getSimpleName();
	private static MQTTConnect manager;
	private static CognitoCredentialsProvider credentialsProvider;
	private AWSIotMqttManager mqttManager;
	CustomLogger log = CustomLogger.getAutomationLog();

	private ConnectionListener mListener;
	private SubscribeListener mSubscribeListener;

	private String IDENTITY_POOL_ID = "us-east-1:3e63b514-6b5d-49e6-b287-aa55bd319476";
	// Customer specific IoT endpoint
	// AWS Iot CLI describe-endpoint call returns:
	// XXXXXXXXXX.iot.<region>.amazonaws.com,
	private String CUSTOMER_SPECIFIC_ENDPOINT = "a1hnqj0olj4641.iot.us-east-1.amazonaws.com";

	private MQTTConnect() {
		// MQTT client IDs are required to be unique per AWS IoT account.
		// This UUID is "practically unique" but does not _guarantee_
		// uniqueness.
		String clientId = UUID.randomUUID().toString();

//		log.info(TAG +"Client Id created: " + clientId);
		credentialsProvider = new CognitoCredentialsProvider("us-east-1:3e63b514-6b5d-49e6-b287-aa55bd319476", Regions.US_EAST_1);


//		log.info(TAG + "credentialsProvider: " + credentialsProvider);

		// MQTT Client
		mqttManager = new AWSIotMqttManager(clientId, CUSTOMER_SPECIFIC_ENDPOINT);
//		log.info(TAG + "Keep Alive: " + mqttManager.getKeepAlive());
		mqttManager.setKeepAlive(3600);
		mqttManager.setAutoReconnect(true);
		mqttManager.setMaxAutoReconnectAttepts(10);
		printSessionInfo();

	}

	public static MQTTConnect getInstance() {
		if (null == manager) {
//			log.info(TAG + "new manager created");
			manager = new MQTTConnect();
//			log.info(TAG + "it came here and is leaving");
		}
		return manager;
	}

	public void setListener(ConnectionListener listener) {
//		log.info(TAG + "this is the value of mListener " + listener);
		this.mListener = listener;
//		log.info(TAG + " value of mListener after this.mListener : " + mListener);
	}

	// set listener
	public void setSubscribeListener(SubscribeListener listener) {
//		log.info(TAG + "this is the value of subscribeListener: " + listener);
		this.mSubscribeListener = listener;
//		log.info(TAG + "this is the value of this.mSubscribeListener : " + mSubscribeListener);
	}

	public void setIdentity(RemoteUser remoteUser) {
		credentialsProvider.setLogins(remoteUser.getLogins());
		printSessionInfo();
	}
	

	public void connect() {
		credentialsProvider.clearCredentials();
		mqttManager.connect(credentialsProvider, mCallback);
//		log.info(TAG + " Connection with MQTT Manager established");
	}

	public void refresh() {
		credentialsProvider.refresh();
		printSessionInfo();
	}

	public void disconnect() {
		mqttManager.disconnect();
	}

	public void reconnect() {
		mqttManager.setAutoReconnect(true);
	}
	
	public void clear() {
		credentialsProvider.clear();
		credentialsProvider.clearCredentials();
		manager = null; // set manager null so that it will re-init the things
	}

	private AWSIotMqttClientStatusCallback mCallback = new AWSIotMqttClientStatusCallback() {
		@Override
		public void onStatusChanged(final AWSIotMqttClientStatus status, final Throwable throwable) {
//			log.info(TAG + " mListener value : " + mListener);
			if (status == AWSIotMqttClientStatus.Connecting) {
				log.info(TAG + " Connecting");
				if (null != mListener) {
					mListener.onStatusChanged(ConnectionState.Connecting);
				}
			} else if (status == AWSIotMqttClientStatus.Connected) {
				log.info(TAG + " Connected");
				if (null != mListener) {
					mListener.onStatusChanged(ConnectionState.Connected);
				}
			} else if (status == AWSIotMqttClientStatus.Reconnecting) {
				if (throwable != null) {
					log.info(TAG + "Connection error." + throwable);
					throwable.printStackTrace();
				}
				if (null != mListener)
					mListener.onStatusChanged(ConnectionState.Reconnecting);
			} else if (status == AWSIotMqttClientStatus.ConnectionLost) {
				if (throwable != null) {
					log.info(TAG + "Connection error." + throwable);
					throwable.printStackTrace();
				}
				if (null != mListener)
					mListener.onStatusChanged(ConnectionState.ConnectionLost);
			}
		}
	};

	public void subscribeTopic(String topic, SubscribeListener mSubscribeListener) throws InterruptedException {
		// this.mSubscribeListener = mSubscribeListener;
		setSubscribeListener(mSubscribeListener);
		Thread.sleep(5000);
		mqttManager.subscribeToTopic(topic, AWSIotMqttQos.QOS0, mIotMqttMessageCallback); // AWSIotMqttQos.QOS0
	}

	public void subscribeAllTopics(String thingName) {
		/*
		 * if (null != credentialsProvider) { credentialsProvider.clear();
		 * credentialsProvider.clearCredentials(); }
		 */
		mqttManager.subscribeToTopic(MqttTopicsHelper.getShadowGetAcceptedTopic(thingName), AWSIotMqttQos.QOS0,
				mIotMqttMessageCallback); // AWSIotMqttQos.QOS0
		mqttManager.subscribeToTopic(MqttTopicsHelper.getShadowGetRejectedTopic(thingName), AWSIotMqttQos.QOS0,
				mIotMqttMessageCallback); // AWSIotMqttQos.QOS0
		mqttManager.subscribeToTopic(MqttTopicsHelper.getShadowUpdateAcceptedTopic(thingName), AWSIotMqttQos.QOS0,
				mIotMqttMessageCallback); // AWSIotMqttQos.QOS0
		mqttManager.subscribeToTopic(MqttTopicsHelper.getShadowUpdateRejectedTopic(thingName), AWSIotMqttQos.QOS0,
				mIotMqttMessageCallback); // AWSIotMqttQos.QOS0
		mqttManager.subscribeToTopic(MqttTopicsHelper.getShadowUpdateDeltaTopic(thingName), AWSIotMqttQos.QOS0,
				mIotMqttMessageCallback); // AWSIotMqttQos.QOS0
		mqttManager.subscribeToTopic(MqttTopicsHelper.getIoTFirmwareUpdateTopic(thingName), AWSIotMqttQos.QOS0,
				mIotMqttMessageCallback); // AWSIotMqttQos.QOS0
	}

	public void publishMessageToTopic(final String topic, final String message) {
		try {
			mqttManager.publishString(message, topic, AWSIotMqttQos.QOS0); // AWSIotMqttQos.QOS0
			log.info(TAG + topic + " published to");

		} /*
			 * catch (AmazonClientException e) { e.printStackTrace(); new (new Runnable() {
			 * 
			 * @Override public void run() { try { mqttManager.publishString(message, topic,
			 * AWSIotMqttQos.QOS0); // AWSIotMqttQos.QOS0 } catch (Exception e1) {
			 * e1.printStackTrace(); } } }, 2000); }
			 */catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void publishMessageToTopic(final String topic, final byte[] data) {
		try {
			mqttManager.publishData(data, topic, AWSIotMqttQos.QOS0);
			log.info(TAG + topic + " published to");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private AWSIotMqttNewMessageCallback mIotMqttMessageCallback = new AWSIotMqttNewMessageCallback() {
		@Override
		public void onMessageArrived(String topic, byte[] data) {
			try {
				String message = new String(data, "UTF-8");
				log.info(TAG + "Message arrived");
				log.info(TAG + "Topic: " + topic);
				log.info(TAG + "Message: " + message);
				/*
				 * Object responseObject = null; if
				 * (topic.equals(RTRemoteUtils.getShadowTopic(MqttTopics.GET_ACCEPTED))) {
				 * responseObject = ResponseParser.getAcceptedResponse(topic, message); } else
				 * if (topic.equals(RTRemoteUtils.getShadowTopic(MqttTopics.GET_REJECTED))) {
				 * responseObject = ResponseParser.getErrorResponse(topic, message); } else if
				 * (topic.equals(RTRemoteUtils.getShadowTopic(MqttTopics.UPDATE_ACCEPTED))) {
				 * responseObject = ResponseParser.getUpdateAcceptedResponse(topic, message); }
				 * else if
				 * (topic.equals(RTRemoteUtils.getShadowTopic(MqttTopics.UPDATE_REJECTED))) {
				 * responseObject = ResponseParser.getErrorResponse(topic, message); } else if
				 * (topic.equals(RTRemoteUtils.getShadowTopic(MqttTopics.UPDATE_DELTA))) {
				 * responseObject = ResponseParser.getUpdateDelta(topic, message); }
				 */

				// These class are more useful for Android based code
				if (null != mSubscribeListener)
					mSubscribeListener.onMessageArrived(topic, message);
				// RTRemoteEvent remoteEvent = new RTRemoteEvent(topic, responseObject);
				// MessageEvent messageEvent = new MessageEvent(Constants.KEY_REMOTE_EVENT,
				// remoteEvent);
				// BusWrapper.sendBroadcast(messageEvent);

			} catch (UnsupportedEncodingException e) {
				log.info(TAG + "Message encoding error." + e);
			} catch (Exception e) {
				log.info(TAG + "Message encoding error." + e);
			}
		}
	};

	public String printSessionInfo() {
		try {
			String identityId = credentialsProvider.getIdentityId();
			log.info(TAG + "identityId: " + identityId);
			/*
			 * PreferencesHelper.getRotimaticSharedPreferences(RotimaticApplication.
			 * getAppContext()) .setCognitoIdentity(identityId);
			 */

			String token = credentialsProvider.getToken();
			String customRoleArn = credentialsProvider.getCustomRoleArn();
			String identityPoolId = credentialsProvider.getIdentityPoolId();
			int refreshThreshold = credentialsProvider.getRefreshThreshold();
			int sessionDuration = credentialsProvider.getSessionDuration();
			// Date sessionCredentitalsExpiration =
			// credentialsProvider.getSessionCredentitalsExpiration();

			log.info(TAG + "======================================================");
			StringBuilder builder = new StringBuilder();
			builder.append("identityId: " + identityId).append("\n").append("token: " + token).append("\n")
					.append("customRoleArn: " + customRoleArn).append("\n").append("identityPoolId: " + identityPoolId)
					.append("\n").append("refreshThreshold: " + refreshThreshold).append("\n")
					.append("sessionDuration: " + sessionDuration);
			// .append("\n").append("sessionCredentitalsExpiration: " +
			// sessionCredentitalsExpiration);
			// log.info(TAG, "SessionInfo: " + builder.toString());

			AWSSessionCredentials mCredentials = credentialsProvider.getCredentials();
			String sessionToken = mCredentials.getSessionToken();
			String accessKeyId = mCredentials.getAWSAccessKeyId();
			String secretKey = mCredentials.getAWSSecretKey();

			builder.append("\n").append("sessionToken: " + sessionToken);
			builder.append("\n").append("accessKeyId: " + accessKeyId).append("\n").append("secretKey: " + secretKey);

			String response = builder.toString();
			log.info(TAG + "SessionInfo: " + response);
			log.info(TAG + "======================================================");
			return response;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public enum ConnectionState {
		Connecting, Connected, ConnectionLost, Reconnecting
	}

	public interface ConnectionListener {
		void onStatusChanged(ConnectionState state);
	}

	public interface SubscribeListener {
		void onMessageArrived(String topic, String message);
		// void onMessageFailure(String topic, String message);

	}
}
